> 今日20、22、1096三题

# 20题-有效的括号

## 题目

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

* 左括号必须用相同类型的右括号闭合。

* 左括号必须以正确的顺序闭合。

  注意空字符串可被认为是有效字符串。

## 思路

利用辅助栈来实现，遇到左括号入栈，遇到右括号出栈，并判断是否对应，不对应则直接返回`false`，最后查看栈是否为空，为空则说明一一对应，返回`true`。

## 实现

```java
class Solution {
public boolean isValid(String s) {
        if(s.length() == 0) return true;
        char[] chs = s.toCharArray();
        Stack<Character> stack = new Stack<>();
        for(char ch : chs) {
            if(ch == '(' || ch == '[' || ch == '{') {
                stack.push(ch);
            } else {
                char ch1 = stack.isEmpty() ?  '?' : stack.pop();
                if (!isTrue(ch1, ch)) return  false;
            }
        }
        return stack.isEmpty();
    }
    public boolean isTrue(char ch1, char ch2) {
        return (ch1 == '(' && ch2 == ')') || (ch1 == '[' && ch2 == ']') || (ch1 == '{' && ch2 == '}');
    }
}
```



# 22题-括号生成

## 题目

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例：

```
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```



## 思路

递归实现。如果左括号还剩余的话，可以拼接左括号；如果右括号剩余多于左括号剩余的话，可以拼接右括号，如果左括号和右括号均没有剩余，则递归结束。

方法一是“约定俗成”的dfs写法。

## 实现

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        if(n == 0) return new ArrayList<>(0);
        List<String> res = new ArrayList<>();
        dfs(res, n, n, new StringBuilder());
        return res;
    }
    public void dfs(List<String> res, int left, int right, StringBuilder path) {
        if(left == 0 && right == 0) {
            // path.toString() 生成了一个新的字符串，相当于做了一次拷贝
            res.add(path.toString());
            return;
        }
        if(left > 0) {
            path.append("(");
            dfs(res, left - 1, right, path);
            path.deleteCharAt(path.length()-1);
        }
        if(right > left) {
            path.append(")");
            dfs(res, left, right - 1, path);
            path.deleteCharAt(path.length()-1);

        }
    }
}
```



```java
class Solution {
    public List<String> generateParenthesis(int n) {
        if(n == 0) return new ArrayList<>(0);
        List<String> res = new ArrayList<>();
        dfs(res, n, n, "");
        return res;
    }
    public void dfs(List<String> res, int left, int right, String path) {  // left、right分别为剩余的左右括号数
        if(left == 0 && right == 0) {
             // 因为每一次尝试，都使用新的字符串变量，所以无需回溯
            res.add(path);
            return;
        }
        if(left > 0) {   // 如果左括号还剩余的话，可以拼接左括号
            // Java里 + 生成了新的字符串，每次往下面传递的时候，都是新字符串。因此在搜索的时候不用回溯。
            dfs(res, left - 1, right, path+"(");
        }
        if(right > left) {  // 如果右括号剩余多于左括号剩余的话，可以拼接右括号
            dfs(res, left, right - 1, path+")");
        }
    }
}
```

# 1096题-花括号展开Ⅱ

## 题目



## 思路



## 实现

```java

```

