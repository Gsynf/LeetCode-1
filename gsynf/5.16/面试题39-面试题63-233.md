> 今日面试题39、面试题63、233三题

# 面试题39-数组中出现次数超过一半的数字

## 题目

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**限制：**

`1 <= 数组长度 <= 50000`

## 思路

注意题目要求，有**一个**而非多个。

1. 首先想到的肯定是使用HashMap进行计数，当某个数字的计数大于数组长度一半，返回该数即可。时间、空间复杂度均为O(N)。
2. 将数组进行排序，若某数字出现个数大于一半，则排序后数组中间位置一定是该数字。
3. **最佳解法-摩尔投票法**。第一次学习到。核心理念就是“正负抵消”，先将一个数设为众数，投票数`votes = 1`，遍历数组，如果遍历到的数组与该数相同，投票数`votes++`，如果不同，投票数`votes--`，若`votes == 0`则说明之前的数字正负抵消，整个数组的众数在剩下的数组中仍未众数，所以从当前数字重新开始，将当前数字设为新的众数，这样只需遍历一次数组，时间复杂度为O(N)，空间复杂度为O(1)。

## 实现

```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        int length = nums.length / 2;  // 满足条件的长度
        for(int i = 0; i < nums.length; i++) {
            if(map.containsKey(nums[i])) { // 如果该数字之前已经出现过
                map.put(nums[i], map.get(nums[i])+1);
            } else {  // 如果该数字之前还没有出现过
                map.put(nums[i], 1);
            }
            if(map.get(nums[i]) > length) {
                return nums[i];
            }
        }
        return 0;
    }
}
```

```java
class Solution {
    public int majorityElement(int[] nums) {
       int votes = 1;  // 投票数
       int mode = nums[0];  // 众数初始化为第一个数字
       for(int i = 1; i < nums.length; i++) {
            if(votes == 0) {
               mode = nums[i];
            }
           if(nums[i] == mode) {
               votes++;
           } else {
               votes--;
           }
       }
       return mode;
    }
}
```



# 面试题63-股票的最大利润

## 题目

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

**限制：**

`0 <= 数组长度 <= 10^5`

## 思路

动态规划，数组`dp[i]`代表第i天结尾的最大收益，dp[i]存在两种情况，若第i天没有卖出，则`dp[i] = dp[i-1]`，若第i天卖出，则`dp[i] = prices[i] - min(prices[0 : i])`，dp[i]取这二者较大值即可。注意数组长度可为0，要处理一下特殊情况。

## 实现

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;
        int minPrice = prices[0];
        int profit = 0;
        for(int i = 1; i < prices.length; i++) {
            minPrice = Math.min(minPrice, prices[i]);
            profit = Math.max(profit, prices[i] - minPrice);
        } 
        return profit;
    }
}
```



# 233题-数字1的个数

## 题目

## 思路

## 实现

```java

```



