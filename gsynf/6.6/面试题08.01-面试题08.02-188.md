> 今日面试题08.01、面试题08.02、188

# 面试题08.01-  三步问题

## 题目

三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

## 思路

动态规划。

## 实现

```java
class Solution {
    public int waysToStep(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        if(n == 3) return 4;
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        dp[2] = 4;
        for(int i = 3;i < n; i++) {
            //取模，对两个较大的数之和取模再对整体取模，防止越界（这里也是有讲究的）
            //假如对三个dp[i-n]都 % 1000000007，那么也是会出现越界情况（导致溢出变为负数的问题）
            //因为如果本来三个dp[i-n]都接近 1000000007 那么取模后仍然不变，但三个相加则溢出
            //但对两个较大的dp[i-n]:dp[i-2],dp[i-3]之和mod 1000000007，那么这两个较大的数相加大于 1000000007但又不溢出
            //取模后变成一个很小的数，与dp[i-1]相加也不溢出
            //所以取模操作也需要仔细分析
            dp[i] = (dp[i-1] + (dp[i-2] + dp[i-3]) % 1000000007) % 1000000007;
        }
        return dp[n-1];
    }
}
```

# 面试题08.02-迷路的机器人

## 题目

设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。

网格中的障碍物和空位置分别用 1 和 0 来表示。

返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

## 思路

动态规划，两步：

1. 先利用动态规划dp数组判断终点是否可达；
2. 如果可达，再按照dp数组的记录从终点返回起点，最后List翻转即可；

## 实现

```java
class Solution {
    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {
        List<List<Integer>> res = new ArrayList<>();
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if(m == 0) return res; // 为空直接返回
        if(obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return res; // 起点或终点有障碍，不可达，直接返回
        int[][] dp = new int[m][n];  // dp[i][j] = 0代表从原点可达，为1代表不可达
        for(int i = 1; i < n; i++) { // 初始化首行是否可达
            if(obstacleGrid[0][i] == 1) {  // 有障碍，不可达
                dp[0][i] = 1;
            } else {
                dp[0][i] = dp[0][i-1];
            }
        }
        for(int i = 1; i < m; i++) { // 初始化首列是否可达
            if(obstacleGrid[i][0] == 1) {  // 有障碍，不可达
                dp[i][0] = 1;
            } else {
                dp[i][0] = dp[i-1][0];
            }
        }
        for(int i = 1; i < m; i++) {  // 判断其他位置是否可达
            for(int j = 1; j < n; j++) {
                if(obstacleGrid[i][j] == 1) {  // 有障碍，不可达
                    dp[i][j] = 1;
                } else {
                    if(dp[i-1][j] == 0 || dp[i][j-1] == 0) {  // 左边或者上边可达且本身无障碍，则可达
                        dp[i][j] = 0;
                    } else {   // 左边喝上边均不可达，则该位置也不可达
                        dp[i][j] = 1; 
                    }
                }
            }
        }
        if(dp[m-1][n-1] == 1) {  // 如果判断终点位置不可达，直接返回
            return res;
        }
        // 如果终点可达，从终点开始倒推
        int row = m-1;
        int col = n-1;
        while(row > 0 || col > 0) {
            res.add(Arrays.asList(row, col));
            if(row == 0) {
                col--;
            } else if(col == 0) {
                row--;
            } else {
                if(dp[row-1][col] == 0) {
                    row--;
                } else if(dp[row][col-1] == 0) {
                    col--;
                }
            }
        }
        res.add(Arrays.asList(0, 0));
        Collections.reverse(res);// 反转res列表中元素的顺序
        return res;
    }
}
```



# 188题-买卖股票的最佳机会Ⅳ

## 题目



## 思路



## 实现

```java

```

