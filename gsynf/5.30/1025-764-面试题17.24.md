> 今日1025、764、面试题17.24

# 1025题-除数博弈

## 题目

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

* 选出任一 x，满足 0 < x < N 且 N % x == 0 。

* 用 N - x 替换黑板上的数字 N 。

如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

## 思路

一、归纳法

若一个数为奇数，那么它的约数一定仍然为奇数；如果一个数为偶数，那么它的约数可以为奇数可以为偶数；

无论N初始多大，最后谁拿到2谁赢；

若N为偶数，那么爱丽丝只需要每次都选1，每次留给鲍勃奇数，鲍勃选的约数只能为奇数，奇数-奇数得到偶数，这样爱丽丝每次都是偶数，一定可以取胜；若N为奇数，那么爱丽丝选择的约数只能为奇数，奇数-奇数得到偶数，那么鲍勃一定会每次只选1，这样爱丽丝必输。

综上，若N为偶数，爱丽丝必赢；若N为奇数，爱丽丝必输。

二、动态规划法

定义数组dp\[i\]表示操作数字i时是否可以获胜。对于如何确定dp\[i\]的值，方法如下：

遍历x = 1 ~ i-1，若x满足x为i的约数且dp\[i-x\] == false，那么操作i时一定选择x即可获胜，此时dp\[i\]即为true，否则为false。

## 实现

```java
// 归纳法
class Solution {
    public boolean divisorGame(int N) {
        return N % 2 == 0;
    }
}
```

```java
class Solution {
    public boolean divisorGame(int N) {
        if(N == 1) return false;
        boolean[] dp = new boolean[N + 1];  // 默认即全为false
        dp[1] = false;
        dp[2] = true;
        for(int i = 3; i <= N; i++) {
            for(int x = 1; x < i; x++) {
                if(i % x == 0 && dp[i-x] == false) {
                    dp[i] = true;
                }
            }
        }
        return dp[N];
    }
}
```



# 764题-最大加号标志

## 题目

在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中，除了在 mines 中给出的单元为 0，其他每个单元都是 1。网格中包含 1 的最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。

一个 k" 阶由 1 组成的“轴对称”加号标志具有中心网格  grid\[x\]\[y\] = 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。下面给出 k" 阶“轴对称”加号标志的示例。注意，只有加号标志的所有网格要求为 1，别的网格可能为 0 也可能为 1。

**k 阶轴对称加号标志示例:**

```
阶 1:
000
010
000

阶 2:
00000
00100
01110
00100
00000

阶 3:
0000000
0001000
0001000
0111110
0001000
0001000
0000000
```

## 思路

## 实现

```java

```



# 面试题17.24-最大子矩阵

## 题目



## 思路



## 实现

```java

```

