> 今日392、1139、546

# 392题-判断子序列

## 题目

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

## 思路

字符串t逐位移动，若等于s中index位，则index向后移动，若index等于s长度，则说明是子序列，否则不是。

## 实现

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        if(s.length() == 0) return true;
        int index = 0;
        for(int i = 0; i < t.length(); i++) {
            if(s.charAt(index) == t.charAt(i)) {
                index++;
            }
            if(index == s.length()) 
                return true;
        }
        return false;
    }
}
```



# 1139题-最大的以1为边界的正方形

## 题目

给你一个由若干 `0` 和 `1` 组成的二维网格 `grid`，请你找出边界全部由 `1` 组成的最大 **正方形** 子网格，并返回该子网格中的元素数量。如果不存在，则返回 `0`。

## 思路

动态规划，指定一个三维数组temp，前两维即网格坐标，第三维长度为2，temp\[i\]\[j\]\[0\]的数值表示该点右边连续为1的个数(包含自己)，temp\[i\]\[j\]\[1\]的数值表示该点下边连续为1的个数(包含自己)。这样，在判断是否为正方形时，不需要遍历四条边每个点，只需要看左上角点对应数组的temp\[i\]\[j\]\[0\]和temp\[i\]\[j\]\[1\]是否满足边长，左下角的点对应的数组temp\[i+edgeLen-1\]\[j\]\[0\]是否满足边长，右上角的点对应的数组temp\[i\]\[j+edgeLen-1\]\[1\]是否满足边长。

## 实现

```java
class Solution {
    public int largest1BorderedSquare(int[][] grid) {
        if(grid.length == 0) return 0;
        int row = grid.length;
        int col = grid[0].length;
        int temp[][][] = new int[row+1][col+1][2];  // 因为会用到temp[row][col][],所以要比grid多一层
        // 完成temp数组按要求装填
        for(int i = row-1; i >= 0; i--) {  
            for(int j = col-1; j >= 0; j--) {
                if(grid[i][j] == 1) {   // 如果连续为1，可累加；如果有0，则重新开始
                    temp[i][j][0] = temp[i][j + 1][0] + 1;   // 在其右边为1的点的数目基础上+1
                    temp[i][j][1] = temp[i + 1][j][1] + 1;   // 在其下边为1的点的数目基础上+1
                }
            }
        }
        // 开始查找最大正方形
        int edgeLen = row;
        while(edgeLen > 0) {
            for(int i = 0; i <= row - edgeLen; i++) {
                for(int j = 0; j <= col - edgeLen; j++) {
                    if (temp[i][j][0] >= edgeLen && temp[i][j][1] >= edgeLen && temp[i + edgeLen -1][j][0] >= edgeLen && temp[i][j + edgeLen -1][1] >= edgeLen){
                    return edgeLen * edgeLen;
                }
            }
            
        }
        // 如果没有满足要求的，边长减一继续从头开始寻找
        edgeLen--;
    }
    return 0;
}
}
```



# 546题-移除盒子

## 题目



## 思路



## 实现

```java

```

