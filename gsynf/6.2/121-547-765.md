> 今日121、547、765

# 121题-买卖股票最佳时机

## 题目

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

## 思路

如果当前价格比之前的最小价格高，那么就会获得利润，计算利润，看是否比之前利润大；如果当前价格比之前最小价格还低，就将最小价格更新为当前价格。

## 实现

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length == 0) return 0;
        int profit = 0;
        int minPrice = prices[0];
        for(int i = 1; i < prices.length;i++) {
            if(prices[i] > minPrice) {
                profit = Math.max(profit, prices[i] - minPrice);
            } else {
                minPrice = prices[i];
            }
        }
        return profit;
    }
}
```



# 547题-朋友圈

## 题目

班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

## 思路

并查集。先定义parents数组，长度为M长度，初始化全为-1，代表每个数都是自己的根节点，遍历M数组，如果某非对角线位置M\[i\]\[j\]为1，那么意味着i和j为朋友，则将parents\[i\]置为j，表示j和i一组，以此类推，最后遍历parents数组，若为-1，则说明为1个根节点，代表一个“朋友圈”。

## 实现

```java
class Solution {
   private static int[] parents;
    public int findCircleNum(int[][] M) {
        //初始化并查集
        int m = M.length;
        int n = M[0].length;
        parents = new int[m];;  //存放每个点的上级
        Arrays.fill(parents, -1);  // 先将parents全部初始话为-1，如果最后还为-1，即为根节点
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(M[i][j] == 1 && i != j){
                    union(i, j);
                }
            }
        }
        int count = 0;
        for(int i = 0; i < parents.length; i ++) {
            if (parents[i] == -1) {
                count ++;
            }
        }
        return count;
    }
    public int find(int idx){   //寻找该节点的根节点
        if(parents[idx] == -1) return idx;
//        while(parents[idx] != -1){
//            //在查找的过程中压缩路径,减少查找的次数
//            parents[idx] = parents[parents[idx]];
//            idx = parents[idx];
//        }
        return find(parents[idx]);
    }

    public void union(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);
        //两个元素的根不同,则合并
        //将其中一个元素的根节点的父亲指向另外的一个元素的根节点
        if(pRoot != qRoot){
            parents[qRoot] = pRoot;
        }
    }


}
```



# 765题-情侣牵手

## 题目



## 思路



## 实现

```java

```

