> 今日面试题16.17-1140-1320

# 面试题16.17-连续数列

## 题目

给定一个整数数组，找出总和最大的连续数列，并返回总和。

示例：

```
输入： [-2,1,-3,4,-1,2,1,-5,4]
输出： 6
解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶**：

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

## 思路

动态规划：定义temp，如果temp为正数，则对当前数值为正向作用，所以加上，如果temp为负值，则加上当前数值必定变小，则舍弃temp，从新开始。若temp大于max，则更新max。

分治：参考题解。连续数列的最大值肯定出现在数组左边或者右边或者横跨左右的中间部分。前两种情况递归即可，第三者情况从中间mid位置分别向左右两边寻找最大值，最后相加即是中间部分的结果，最后左边、右边、中间三部分结果取最大值即可。

参考[这里](https://blog.csdn.net/abnerwang2014/article/details/36027747)，很详细。

## 实现

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length == 1) return nums[0];
        int max = nums[0];
        int temp = max;
        for(int i = 1; i < nums.length; i++) {
            if(temp > 0) {
                temp += nums[i];
            } else {
                temp = nums[i];
            }
            if(temp > max) {
                max = temp;
            }
        }
        return max;
    }
}
```

```java
// 分治
class Solution {
  public int maxSubArray(int[] nums) {
    		return maxSub(nums,0,nums.length-1);
    }
    public static int maxSub(int[]nums,int left,int right )
    {
		//一定将左右边界最大初始化为MIN_VALUE，初始化为0的时候全为负数过不去
		int maxleftbordersum =  Integer.MIN_VALUE,maxrightbordersum = Integer.MIN_VALUE; 
		int leftmaxsum = Integer.MIN_VALUE,rightmaxsum = Integer.MIN_VALUE;				
		int leftbordersum = 0,rightbordersum = 0;
		
		int mid = left+(right-left)/2;
		if(left==right)
		{
			return nums[left];
		}
		leftmaxsum = maxSub(nums,left,mid);		//计算得到左子数组的最大值
		rightmaxsum= maxSub(nums,mid+1,right);	//计算得到右子数组的最大值
		
		for(int i = mid;i >= left ;i--)		//一定要从中间向两端加！！！
		{
			leftbordersum += nums[i];
			if(leftbordersum > maxleftbordersum)
				maxleftbordersum = leftbordersum;
		}
		
		for(int i = mid+1 ;i <= right;i++)
		{
			rightbordersum += nums[i];
			if(rightbordersum > maxrightbordersum)
				maxrightbordersum = rightbordersum;
		}
		//返回三者最大值
		return Integer.max(leftmaxsum,Integer.max(rightmaxsum,maxleftbordersum+maxrightbordersum));
    }
}

```



# 1140题-石子游戏Ⅱ

## 题目

亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。

亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。

在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 <= X <= 2M。然后，令 M = max(M, X)。

游戏一直持续到所有石子都被拿走。

假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。

## 思路

两者都发挥“最佳水平”的含义即为每当轮到自己拿石子的时候，要在后继的所有状态中，选择对自己最有利的，也就是遍历所有后继状态，选择一个最优解。

设`dfs(i, M)`表示从第`i`堆石子开始拿，可以拿`1 <= x <= 2M`时，在剩余石子中可以取到的最大值。对于题目来说，最后结果就是返回`dfs(0, 1)`。具体来看：

1. 如果`i > n`，说明已经超出最后的石子堆，返回0；
2. 如果`i+2M >= n`，说明剩余石子堆可以一次性全部拿走，直接返回剩余所有石子的数目`sum[piles.length] - sum[i-1]`；
3. 如果非上述情况，那么如果在面临第`i`堆的时候选择了拿`x`堆，那么对手下一轮的情况就是`dfs(i+x, max(M, x))`，所以需要在面临第`i`堆时，遍历`x(1 <= x <= 2M)`，使得`dfs(i+x, max(M, x))`最小（对手收益最少，自己收益就最大）
4. 存在重复搜索，所以采用记忆化的方法，采取memo\[\]\[\]来记录，同时利用sum数组来记录截止目前堆，所有石子的数目；

## 实现

```java
class Solution {
    public int[][] memo;
    public int[] sum;
    public int stoneGameII(int[] piles) {
        int n = piles.length;
        memo = new int[n+1][n*n];
        sum = new int[n+1];
        sum[1] = piles[0];
        // sum[i]记录截止第i堆，所有石子的数目
        for(int i = 0; i < n; i++) {
            sum[i+1] = sum[i] + piles[i];
        }
        return dfs(piles, 1, 1, n);
    }
    public int dfs(int[] piles,int i, int M, int n) {
        // 记忆化深搜，如果存过，直接返回存储即可
        if(memo[i][M] != 0) return memo[i][M];
        if(i > n) return 0;
        if(i + 2 * M > n) {
            return sum[n] - sum[i-1];
        }
        int max = 0;
        for(int j = i+1; j <= i + 2*M; j++) {
            // 遍历自己拿x堆（1-2M），看对手收益
            int next = dfs(piles, j, Math.max(j-i, M), n);
            // 剩余所有石子总数减去对手能拿走的，即是自己的
            max = Math.max(max, sum[n] - sum[i-1] - next);
        }
        // 进行记录
        memo[i][M] = max;
        return memo[i][M];
    }
}
```



# 1320题-二指输入的最小距离

## 题目



## 思路



## 实现

```java

```

