> 今日111、1306、847

# 111题-二叉树的最小深度  

## 题目

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

## 思路

递归。

## 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        // 左子树深度
        int left = minDepth(root.left);
        // 右子树深度
        int right = minDepth(root.right);
        // 1.左右子树深度均为0，返回1即可；
        // 2.左右子树其中一个深度为0，返回另一个深度+1即可；
        // 3.左右子树深度均不为0，返回其中较小者+1即可；
        return (left == 0 || right ==0) ? left + right + 1 : Math.min(left, right) + 1;
    }
}
```



# 1306题-跳跃游戏III

## 题目

这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。

请你判断自己是否能够跳到对应元素值为 0 的 任意 下标处。

注意，不管是什么情况下，你都无法跳到数组之外。

## 思路

dfs，从start位置开始搜，直到找到或者不满足条件递归结束。

## 实现

```java
class Solution {
    public boolean canReach(int[] arr, int start) {
        boolean[] visited = new boolean[arr.length];  // 如果被访问过的位置再次被访问，可能会出现循环，不满足条件
        return dfs(arr, start, visited);
    }
    public boolean dfs(int[] arr, int start, boolean[] visited) {
        // 如果start位置直接就是0
        if(arr[start] == 0) return true;
        // 记录start位置已被访问
        visited[start] = true;
        // 处理start左边的元素
        int left = start - arr[start];
        if(left >= 0 && !visited[left] && dfs(arr, left, visited)) return true;
         // 处理start右边的元素
        int right = start + arr[start];
        if(right < arr.length && !visited[right] && dfs(arr, right, visited)) return true;
        // 没有能达到0的位置
        return false;
    }
}
```



# 847题-访问所有节点的最短路径

## 题目



## 思路



## 实现

```java

```

