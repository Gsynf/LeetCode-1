> 今日9、5、124三题

# 9题-回文数

## 题目

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

## 思路

首先，特殊情况，如果为负数，肯定不是，如果长度为1，则肯定是。其他情况，可以通过循环取余的方式先将每一位都取出来放到一个StringBuilder中，再依次判断对称位置数字是否相同，判断方法为将StringBuilder转换为String，判断String对应位的char即可。

进阶方法：同样是不断取最后一位，但是取得最后一位后加上之前取得数字*10，例如原数为1221，先取得1，再取得2，1 * 10 + 2 = 12，直到取得长度达到原数长度一半，如何判断？因为原数不断处以10，所以当原数小于该数时，即达到。

## 实现

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x < 0) return false;
        if(x >= 0 && x <= 9) return true;
        StringBuilder sb = new StringBuilder();
        while(x != 0) {
            int mod = x % 10;
            sb.append(mod);
            x = x /10;
        }
        String s = sb.toString();
        for(int i = 0; i < sb.length()/2; i++) {
            if(s.charAt(i) != s.charAt(sb.length()-1-i)) {
                return false;
            }
        }
        return true;
    }
}
```

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x >= 0 && x <= 9) return true;
        if(x < 0 || x % 10 == 0) return false;
        
        int tempRes =  0; 
        while(x > tempRes) {
            tempRes = tempRes * 10 + x % 10;  // tempRes每次加上目前x的最后一位
            x = x / 10; // x不断缩小
        }
        //System.out.println(x);
        //System.out.println(tempRes);
        // 对于x为奇数这种情况，tempRes最后会多一位，但不影响结果，所以temRes/10再比较
        return x == tempRes || x == tempRes / 10;
    }
}
```



# 5题-最长回文子串

## 题目

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

## 思路

动态规划，dp\[i\]\[j\]表示字符串s\[i , j\]是否为回文子串，则状态转移方程为：

`dp[i][j] = s[i]==s[j] and dp[i+1][j-1]`，边界条件为s\[i+1, j-1\]有意义，即该子串长度大于2，`(j-1)-(i+1) + 1 > 2`，即`j-i < 3` 。

初始化：子串长度为1时，肯定为回文，所以dp\[i, i]均为true；

过程：![DP举例](https://i.loli.net/2020/05/25/UjZoA8erNsCXFfi.png)

## 实现

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;
        int maxLen = 1; // 记录最大长度值
        int index = 0; // 记录最大长度值对应的起始索引位置
        boolean dp[][] = new boolean[len][len];  // dp[i][j]表示子串s[i, j]是否为回文
        for(int i = 0; i < len; i++) {  // 初始化对角线元素均为true，长度为1的子串肯定为回文
            dp[i][i] = true;
        }
        // 若dp[i][j] = dp[i+1][j-1]，则dp[i][j]的值取决于其左下角的值，所以按列填，而非按行
        for(int j = 1; j < len; j++) {
            for(int i = 0; i < j; i++) {
                if(s.charAt(j) != s.charAt(i)) {
                    dp[i][j] = false;
                } else {
                    if(j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                if(dp[i][j] && j - i + 1 > maxLen) {// 如果dp[i,j]为回文且长度大于maxLen
                    maxLen = j - i + 1;
                    index = i;
                }
            }
        }
        return s.substring(index, index + maxLen);
    }
}
```

# 124题-二叉树中的最大路径和

## 题目

## 思路

## 实现

```java

```



