> 今日1046、973、778三题

# 1046题-最后一块石头的重量

## 题目

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且` x <= y`。那么粉碎的可能结果如下：

* 如果 `x == y`，那么两块石头都会被完全粉碎；
* 如果 `x != y`，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

## 思路

1. java的排序是从小到大的，所以就是取最后两位，将小石头完全粉碎的结果0和大石头剩余的结果weight重新放入数组，再次排序，只需要循环 `stones.length-1` 次，stones数组就是0和所求的值。
2. 优先队列，内部降序。

## 实现

```java
class Solution {
    public int lastStoneWeight(int[] stones) {
        int weight = 0;
        for(int i = 0; i < stones.length - 1; i++) {
            Arrays.sort(stones);
            weight = stones[stones.length-1] - stones[stones.length-2];
            stones[stones.length-2] = 0;
            stones[stones.length-1] = weight;
        }
        return stones[stones.length-1];
    }
}
```

```java
class Solution {
    public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> heap = new PriorityQueue<>((o1, o2) -> o2-o1);  // 优先队列默认升序，需要改为降序
        for(int stone : stones) {
            heap.add(stone);
        }
        while(heap.size() >= 2) {
            int max1 = heap.poll();
            int max2 = heap.poll();
            int diff = max1 - max2;
            heap.offer(diff);
        }
        return heap.poll();
    }
}
```



# 973题-最接近原点的K个点

## 题目

我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。

（这里，平面上两点之间的距离是欧几里德距离。）

你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。

提示：

```
1 <= K <= points.length <= 10000
-10000 < points[i][0] < 10000
-10000 < points[i][1] < 10000
```

## 思路

1. 遍历，将所有点到原点的距离均计算出来并排序，找到第k个小的disK，再次遍历，距离不大于disK的即满足条件；
2. 优先队列，内部其实是堆排序；
3. 快排；

## 实现

```java
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        int[] dis = new int[points.length];
        for(int i = 0; i < points.length; i++) {
            dis[i] = points[i][0] * points[i][0] + points[i][1] * points[i][1];
        }
        Arrays.sort(dis);
        int disK = dis[K-1];
        int[][] res = new int[K][2];
        int j = 0;
        for(int i = 0; i < points.length; i++) {
            if(points[i][0] * points[i][0] + points[i][1] * points[i][1] <= disK) {
                res[j++] = points[i];
            }
            if(j == K-1)  // 如果K个都已经找到，就不需要再找了
                continue;
        } 
        return res;
    }
}
```

```java
public int[][] kClosest(int[][] points, int K) {
    if (null == points || points.length == 0) {
        return null;
    }
    PriorityQueue<int[]> queue = new PriorityQueue<>(K, new Comparator<int[]>() {
        @Override
        public int compare(int[] o1, int[] o2) {
            int distance1 = o1[0] * o1[0] + o1[1] * o1[1];
            int distance2 = o2[0] * o2[0] + o2[1] * o2[1];
            return distance1 - distance2;
        }
    });
    queue.addAll(Arrays.asList(points));
    int[][] res = new int[K - 1][2];
    for (int i = 0; i < K; i++) {
        res[i] = queue.poll();
    }
    return res;
}
```

```java

```



# 778题-水位上升的泳池中游泳

## 题目



## 思路



## 实现

```java

```

