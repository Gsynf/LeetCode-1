> 今日507题、869题、458题

# 507题-完美数

## 题目

对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。

给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False。

**示例：**

```
输入: 28
输出: True
解释: 28 = 1 + 2 + 4 + 7 + 14
```

**提示：**

输入的数字 n 不会超过 100,000,000. (1e8)

## 思路

枚举。i从1到sqrt(num)，如果i可以被num整除，那么sum就加上i，再加上另一个约数num/i，如果i等于sqrt(num)，那么只加一次，最后的sum还包含num，所以看sum是否等于两倍的num即可。

## 实现

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num == 0) return false;
        int sum = 0;
        for(int i = 1; i <= Math.sqrt(num); i++) {
            if(num % i == 0) {
                if(i != Math.sqrt(num)) {
                    sum += i;
                    sum += num/i;
                } else {
                    sum += i;
                }
            }
        }
        return sum == num * 2;
    }
}
```

# 869题-重新排序得到2的幂

## 题目

给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。

**提示：**`1 <= N <= 10^9`

## 思路

由于N最大10^9，也就是不会大于2^31，又可以随意排序，所以就比较N中0-9各个数字的数目（类似于位图法）和2^n中0-9各个数字的数目是否相同即可。

## 实现

```java
class Solution {
    public boolean reorderedPowerOf2(int N) {
        int[] res = count(N);
        for(int i = 0; i < 31; i++) {
            if(Arrays.equals(res, count(1 << i))) 
                return true;
        }
        return false;
    }
    // Eg. N = 112223334, returns [0,2,3,3,1,0,0,0,0,0]
    public int[] count(int n) {
        int[] nums = new int[10];
        while(n != 0) {
            nums[n % 10]++;
            n = n / 10;
        }
        return nums;
    } 
}
```



# 458题-可怜的小猪

## 题目



## 思路



## 实现

```java

```

