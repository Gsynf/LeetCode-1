> 今日746、718、123

# 746题-使用最小花费爬楼梯  

## 题目

数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

## 思路

动态规划，递归方程为：`f[i] = cost[i] + min(f[i-1], f[i-2])`

## 实现

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int c1 = 0;
        int c2 = 0;
        for(int c : cost) {
            int cur = c + Math.min(c1, c2);
            c1 = c2;
            c2 = cur;
        }
        return Math.min(c1, c2);
    }
}
```

# 718题-最长重复子数组

## 题目

给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。

## 思路

定义一个二维数组C，若`A[i]==B[j]`，则`C[i][j] = C[i-1][j-1] + 1`，若`A[i] != B[j]`，则`C[i][j] = 0` ，最后结果统计数组C中的最大值即可。

## 实现

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int[][] C = new int[A.length+1][B.length+1];
        int maxLen = 0;
        for(int i = 1; i < A.length + 1; i++) {
            for(int j = 1; j < B.length + 1; j++) {
                if(A[i-1] == B[j-1]) {
                    C[i][j] = C[i-1][j-1] + 1;
                }
                if(C[i][j] > maxLen) {
                    maxLen = C[i][j];
                }
            }
        }
        return maxLen;
    }
}
```



# 123题-买卖股票的最佳机会III

## 题目



## 思路



## 实现

```java

```

