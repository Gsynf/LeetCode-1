> 今日122、378、352

# 122题-买卖股票最佳时机Ⅱ

## 题目

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 思路

遍历数组，只要价格比前一天高，就加入利润。

## 实现

```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for(int i = 0; i < prices.length-1; i++) {
            if(prices[i+1] > prices[i]) {
                profit += prices[i+1] - prices[i];
            }
        }
        return profit;
    }
}
```



# 378题-有序矩阵中第k小的元素

## 题目

给定一个 *n x n* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

**提示：**
你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n^2 。

## 思路

1. 使用优先队列（即内部排好序的队列），始终保持队列数目为k个，且队列中存的是矩阵中最小的k个数，这样最后返回队列首部元素即可；

2. 二分法。矩阵中最小的数字肯定为左上角，最大的数字为右下角，mid为`left+(right-left)/2`，在矩阵中统计不超过mid的数的数目count，如果count小于k，那么要找的结果必定在(mid, right\]，如果count大于等于k，那么要找的结果必定在\[left, mid\]，继续二分，一直到`left == right`时返回结果。

   至于如何统计count，从左下角开始，当前数小等于mid，当前数所在列其上的所有数均小于mid，统计上即可，然后向右走；如果当前数大于mid，则往上走继续找小一点的数。

## 实现

```java
// 优先队列
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        PriorityQueue<Integer> maxK = new PriorityQueue<>(cmp);  // 优先队列默认为升序，所以需要自定义排序方式为降序，保证队列首部为最大值
        for(int[] row : matrix) {
            for(int num : row) {
                if(maxK.size() == k && num > maxK.peek()) // 因为矩阵每一行为升序，如果优先队列已满k且当前数比队列最大数还大，那么之后的数更大，则不需要再入列，直接break去下一行即可
                    break;
                maxK.add(num);
                if(maxK.size() > k) // 如果队列数目大于k，则删除最大的一个，保证队列数目为k
                    maxK.remove();
            }
        }
        return maxK.remove();
    }
    //自定义比较器，降序排列
    static Comparator<Integer> cmp = new Comparator<Integer>() {
      public int compare(Integer e1, Integer e2) {
        return e2 - e1;
      }
    };
}
```

```java
// 二分法
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length -1;
        int left = matrix[0][0];
        int right = matrix[n][n];
        while(left < right) {
            int mid = left + (right - left) / 2;
            int count = countNotMoreThanMid(matrix, mid, n);
            if(count < k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
    public int countNotMoreThanMid(int[][] matrix, int mid, int n) {
        int count = 0;
        int col = 0, row = n; // 从左下角的数字开始比较
        while(col <= n && row >= 0) {
            if(matrix[row][col] <= mid) {   // 如果该数字比mid小
                count += row + 1;  // 那么该数字所在列其上部全比mid小
                col++;   // 移到下一行，向右走
            } else {
                row--;   // 向上走
            }
        }
        return count;
    }
        
}
```



# 352题-将数据流变为多个不相交区间

## 题目



## 思路



## 实现

```java

```

